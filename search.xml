<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Q-learning-sarsa-sarsa-lambda]]></title>
    <url>%2FAlgorithm%2FQ-learning-sarsa-sarsa-lambda%2F</url>
    <content type="text"><![CDATA[强化学习三兄弟 ​ 哈喽，欢迎来到阿方小课堂，强化学习学的我晕乎乎的，下面我把自己这几天的理解收获整理一下，欢迎在评论区向我指出错误。 Q-learning与SarsaQ-learning是Off-policy（离线学习）,而Sarsa是On-policy（在线学习），他们的区别是，Sarsa 是说到做到型，即边做边学；而Q-Learning是说到但并不一定做到，其可以通过观察别人的经历来学习。二话不说，贴出伪代码 其中，r表的含义在这，假设我们的 Q(s, a) ​是一个 Q table，如下图所示，该表格表示共有三个 state (状态)： S_1​ 、​S_2​、​S_3​ ,每个状态都有三个可选 action (动作) ：​a_1​、​a_2​、​a_3 ，对所有的状态-动作以0赋值： | Q(s,a) | a_1 | a_2 | a_3 || :——- | :—: | :—: | —-: || S_1 | 0 | 0 | 0 || S_2 | 0 | 0 | 0 || S_3 | 0 | 0 | 0 | ​ Q-learning 算法和 Sarsa 算法都是从状态s开始，根据当前的 Q table 使用一定的策略（ε - greedy）选择一个动作$a$，然后观测到下一个状态s’，并再次根据 Q table 选择动作a’。 可以看出更新 Q(s, a) 需要用到下一个状态的动作a’，而两种算法的不同点正是选取a’的方法不同。根据算法描述，在选择新状态s’的动作a’时，Q-learning使用贪心策略(greedy)，即选取值最大的a’，此时只是计算出哪个a’可以使Q(s, a)取到最大值，然后更新Q table，并没有真正采用这个动作a’。贴出Q-learning更新Q table的代码。 123456789101112for i in range(1000): # 对每一个训练,随机选择一种状态 state = random.randint(0, 5) while state != 5: # 选择r表中非负的值的动作 r_pos_action = [] for action in range(6): if r[state, action] &gt;= 0: r_pos_action.append(action) next_state = r_pos_action[random.randint(0, len(r_pos_action) - 1)] q[state, next_state] = r[state, next_state] + gamma * q[next_state].max() state = next_state 而 Sarsa 则是仍使用ε - greedy策略，并真正采用了这个动作a’。代码如下： 123456789101112131415161718192021222324for i in range(100000): # 对每一个训练,随机选择一种状态 state = random.randint(0, 5) while state != 5: # 选择r表中非负的值的动作 actions = [] for a in range(6): if r[state, a] &gt;= 0: actions.append(a) # 采取动作 action = actions[random.randint(0, len(actions) - 1)] R = r[state, action] next_state = action actions = [] for a in range(6): if r[next_state, a] &gt;= 0: actions.append(a) # 采取相同的动作（sarsa核心） next_action = actions[random.randint(0, len(actions) - 1)] q[state, action] = R + gamma * q[next_state, next_action] state = next_state action = next_action Q-Learning因为有了 maxQ，所以也是一个特别勇敢的算法，原因在于它永远都会选择最近的一条通往成功的道路，不管这条路会有多危险。而 Sarsa 则是相当保守，它会选择离危险远远的。 Sarsa与Sarsa-lambdaSarsa-lambda与Sarsa相似，都是On-policy，但是在每次take action获得reward后，Sarsa只对前一步Q(s,a)进行更新，Sarsa-lambda则会对获得reward之前的步进行更新。它到终点后会再反过来看一下自己曾经走过的路。 ​ 大体上与Sarsa相同，只是增加一个指标，这样可以使学习效率变高，能更快速的达到目的Q表。 这个指标就是在获取到最终奖励时，也可以说是到达最终目的地时，各个位置的不可或缺性。 表示方法： 先定义一个E表，用来记录经过的位置，每走一步，如果这个点不在E表中，则添加这个点到E表中，并将这个E(s,a)的值改为+1（还可以优化，下面说），如果表中存在这个位置，则直接更新这个位置的值，然后在走下一步之前对E表进行整体衰减。也就是说每走一步，就要对E表的当前位置的值进行刷新，然后再进行衰减。衰减的意义就在于如果一旦到达终点，就可以体现出来E表中各个位置对到达终点的不可或缺性。如果衰减比例为0，也就是每次都给E表里的值乘0，就意味着表里最后就剩下一个离终点最近的位置了，如果为1呢，则E表里的重复的越多的位置收益越大（so，这不合理，需要优化），所以，衰减比例应该取一个0~1之间的数比较合理。 E表的用法就是在Sarsa的基础上，每次更新的时候加上这个E表里对应位置的值就可以了。这就是传说中的Sarsa lambda了。下面说一下如何优化： 前面我们说每次经过这个某个位置，都把E表里对应值+1，这样对有些位置会很不公平，可能会出现离终点最近的那个位置的E值比中间的某个点的E值还要低，这很不科学。优化办法就是给E里的值定个上限，每次走到这个位置，就把他重新定为1，然后从1开始衰减，这样就不会出现上述的bug了。 简单介绍一下图里的内容，第一行说的是某个位置出现和时间的关系；第二行说的是E值+1那个情况；第三行说的是定个上限为1的规矩。 总结哇~强化三兄弟的介绍就这么结束了，对亏了简书，知乎，CSDN等论坛上的各路大神，贴上URL https://zhuanlan.zhihu.com/p/29283927 https://blog.csdn.net/u010089444/article/details/80516345 https://www.jianshu.com/p/91fbc682fb3e 安呐~]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RNN+LSTM]]></title>
    <url>%2FAlgorithm%2FRNN-LSTM%2F</url>
    <content type="text"><![CDATA[RNN+LSTM Why we need RNN?​ 普通的神经网络虽然强大，但是只能单独的去处理一个个的输入，前一个输入和后一个输入是完全没有关系的。但是，某些任务需要能够更好的处理序列的信息，即前面的输入和后面的输入是有关系的。比如，当我们在理解一句话意思时，孤立的理解这句话的每个词是不够的，我们需要处理这些词连接起来的整个序列；当我们处理视频的时候，我们也不能只单独的去分析每一帧，而要分析这些帧连接起来的整个序列。 以nlp的一个最简单词性标注任务来说，将我 吃 苹果 三个单词标注词性为 我/nn 吃/v 苹果/nn。 这个任务的输入是：我 吃 苹果 （已经分词好的句子） 这个任务的输出是：我/nn 吃/v 苹果/nn (词性标注好的句子) 对于这个任务来说，我们当然可以直接用普通的神经网络来做，给网络的训练数据格式了就是我-&gt; 我/nn 这样的多个单独的单词-&gt;词性标注好的单词。 但是很明显，一个句子中，前一个单词其实对于当前单词的词性预测是有很大影响的，比如预测苹果的时候，由于前面的吃是一个动词，那么很显然苹果作为名词的概率就会远大于动词的概率，因为动词后面接名词很常见，而动词后面接动词很少见。 所以为了解决一些这样类似的问题，能够更好的处理序列的信息，RNN就诞生了。 RNN的结构循环神经网络的隐藏层的值s不仅仅取决于当前这次的输入x，还取决于上一次隐藏层的值s。权重矩阵 W就是隐藏层上一次的值作为这一次的输入的权重。 LSTM​ RNN功能这么强大，那么LSTM又是干什么的呢？ ​ RNN 是在有顺序的数据上进行学习的. 为了记住这些数据, RNN 会像人一样产生对先前发生事件的记忆。 ​ 想像现在有这样一个 RNN, 他的输入值是一句话: “我今天要去北京旅游, 首先我要坐大巴去机场，然后登上飞机，经过漫长的旅途，就到站啦。”那么用 RNN 来分析, 我今天去了什么地方呢？ RNN可能会给出“菏泽”这个答案。因为结论出错, RNN就要开始学习这么长一段话和 “北京“的关系 , 而RNN需要的关键信息 ”北京”却出现在句子开头。 ​ ”北京“这个信息的记忆要进过长途跋涉才能抵达最后一个时间点，然后我们得到误差。而且在反向传递得到的误差的时候，他在每一步都会乘以一个自己的参数 W。如果这个 W 是一个小于1的数, 比如0.9。这个0.9不断乘以误差, 误差传到初始时间点也会是一个接近于零的数, 所以对于初始时刻, 误差相当于就消失了。我们把这个问题叫做梯度消失或者梯度弥散。 反之如果 W 是一个大于1的数，比如1.1。不断累乘，则到最后变成了无穷大的数，RNN被这无穷大的数撑死了, 这种情况我们叫做梯度爆炸。 这就是普通 RNN 没有办法回忆起久远记忆的原因。 ​ LSTM 就是为了解决这个问题而诞生的。LSTM 和普通 RNN 相比，多出了三个控制器(输入控制，输出控制，忘记控制)。现在, LSTM内部的情况是这样： ​ 多了一个控制全局的记忆, 我们用粗线代替.。输入控制，输出控制，忘记控制三个控制器都是在原始的 RNN 体系上, 我们先看输入方面 , 如果此时的分线剧情对于剧终结果十分重要, 输入控制就会将这个分线剧情按重要程度写入主线剧情进行分析. 再看忘记方面, 如果此时的分线剧情更改了我们对之前剧情的想法, 那么忘记控制就会将之前的某些主线剧情忘记, 按比例替换成现在的新剧情。所以主线剧情的更新就取决于输入和忘记 控制。最后的输出方面, 输出控制会基于目前的主线剧情和分线剧情判断要输出的到底是什么。基于这些控制机制, LSTM就可以带来更好的结果。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CNN]]></title>
    <url>%2FAlgorithm%2FCNN%2F</url>
    <content type="text"><![CDATA[卷积神经网络（CNN） 一、我们需要CNN​ 在全连接神经网络中，每相邻两层之间的每个神经元之间都是有边相连的。当输入层的特征维度变得很高时，这时全连接网络需要训练的参数就会增大很多，计算速度就会变得很慢，例如一张黑白的 28×28 的手写数字图片，输入层的神经元就有784个，如下图所示： ​ 若在中间只使用一层15个神经元的隐藏层，那么参数 w 就有 784 × 15 = 11760 多个；若输入的是 28×28 带有颜色的RGB格式的手写数字图片，那么参数 w 的个数还需要再乘以 3。这很容易看出使用全连接神经网络处理图像中的需要训练参数过多的问题。 ​ 而在卷积神经网络（Convolutional Neural Network,CNN）中，卷积层的神经元只与前一层的部分神经元节点相连，即它的神经元间的连接是非全连接的，且同一层中某些神经元之间的连接的权重 w 和偏移 b 是共享的（Shared Weights），这样大量地减少了需要训练参数的数量。 二、CNN的卷积层在卷积层中有几个重要的概念： 1、Local receptive fields（感受野） 假设输入的是一个 28×28 的的二维神经元，我们定义5×5 的 一个 Local receptive fields（感受野），即隐藏层的神经元与输入层的 5×5 个神经元相连，这个 5×5 的区域就称之为 Local Receptive Fields，如下图所示： ​ 2、Shared weights（共享权值） 隐含层的每一个神经元都连接 5x5个图像区域，也就是说每一个神经元存在 25个连接权值。也就是说下一层的每个神经元如果用的是同一个卷积核去卷积图像。这样我们就只有 25 个参数啊！不管你隐层的神经元个数有多少，两层间的连接我只有 25 个参数啊！这就是卷积神经网络的主打卖点。 ​ ​ 但是，你就会想，这样提取特征也忒不靠谱吧，这样你只提取了一种特征啊？我们需要提取多种特征啊！假如一种滤波器只提取图像的一种特征，那么我们需要提取不同的特征，怎么办，加多几种滤波器不就行了吗？所以假设我们加到 100 种滤波器，每种滤波器的参数不一样，表示它提出输入图像的不同特征。这样每种滤波器去卷积图像就得到对图像的不同特征的放映，我们称之为Feature Map。所以 100 种卷积核就有 100 个 Feature Map。这 100 个 Feature Map 就组成了一层神经元。所以我们这一层有多少个参数了？100 种卷积核 x 每种卷积核共享 25 个参数= 100 x 25 = 2500，也就是2500个参数。 需要注意的一点是，上面的讨论都没有考虑每个神经元的偏置部分。所以权值个数需要加1 。这个也是同一种滤波器共享的。因此在CNN的卷积层，我们需要训练的参数大大地减少到了 (5×5+1)×100=2600个。 三、“卷积”操作​ 当给一张新的图时，CNN并不能准确地知道这些 Features 到底要匹配原图的哪些部分，所以它会在原图中每一个可能的位置进行尝试。这样在原始整幅图上每一个位置进行匹配计算。这个我们用来匹配的过程就被称为卷积操作，这也就是卷积神经网络名字的由来。 这个卷积操作背后的数学知识其实非常的简单。要计算一个滤波器和其在原图上对应的某一小块的结果，只需要简单地将两个小块内对应位置的像素值进行乘法运算，然后将整个小块内乘法运算的结果累加起来，最后再除以小块内像素点总个数即可。 ​ 我们以上图为例，卷积神经元的output是如何计算出来的。蓝色区域和红色区域对应的数字进行相乘然后再求和，最后和Bias相加，得到对应的数字，依次存放到绿色矩阵里面。第一个矩阵结果是3， 第二个矩阵的结果是2，第三个矩阵的结果是0，所以3 + 2 + 0 = 5，最后加上第一个Bias参数1，所以第一个333的区域神经输出结果是 6。 ​ 然后依次进行。 四、池化(Pooling)​ 当输入经过卷积层时，若感受野比较小，步长stride比较小，得到的feature map（特征图）还是比较大，可以通过池化层来对每一个 feature map 进行降维操作，输出的深度还是不变的，依然为 feature map 的个数。 ​ 池化可以将一幅大的图像缩小，同时又保留其中的重要信息。池化背后的数学顶多也就是小学二年级水平。它就是将输入图像进行缩小，减少像素信息，只保留重要信息。通常情况下，池化都是 2×2 大小，比如对于 max-pooling 来说，就是取输入图像中 2×2 大小的块中的最大值，作为结果的像素值，相当于将原始图像缩小了 4 倍。(注：同理，对于average-pooling来说，就是取 2×2 大小块的平均值作为结果的像素值。) ​ 所以，池化的实质就是把图片变模糊了，相当于给图片打了马赛克，如下图： 通过加入池化层，可以很大程度上减少计算量，降低机器负载。 到现在为止，已经讲了从输入到池化的过程，图片也从原来的 28 × 28 变成了 12 × 12，如下图 ​ 五、激活函数Relu (Rectified Linear Units)这里，我们用Relu作为激活函数： 六、全连接层(Fully connected layers)​ 卷积神经网络的目的就是降低网络复杂度，减少权值W和偏置值b的个数，它不是一个完整的网络，所以，在最后还须加入普通的神经网络（全连接层）。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[南巡，难寻——黄山]]></title>
    <url>%2Ftravel%2F%E5%8D%97%E5%B7%A1%EF%BC%8C%E9%9A%BE%E5%AF%BB%E2%80%94%E2%80%94%E9%BB%84%E5%B1%B1%2F</url>
    <content type="text"><![CDATA[南巡，难寻——黄山 ​ 岳归否山，黄归否岳。 ​ 南巡之行已至终程，景色无边，钱袋空虚，行囊也愈发沉重。将背包寄存在山下，买过票后（票是真滴贵），坐上登山汽车。远远看去，山势蜿蜒起伏，其色绿褐交织，幻想着奇松怪石，险涧飞瀑。心仪已久的黄山美人儿终于要慢慢揭开她的面纱，内心激荡翻滚。 ​ 望山跑死马，正当我担心路上是否有加油站时，汽车终于到了。不是假期的周末，依旧人流漫山。车停在慈光阁处（我们选择从前山上山，最后了解到真相唏嘘不已），身处黄山山脉中，不识东西南北，更不见黄山真相。 缆车处排了好长的队，我不愿等，于是选择步行上山，顺便可以观路途风景。（步行上山是我做过的最智障累成狗的决定） ​ 从慈光阁一路爬行，期间经过了像立马亭这样的无数个小站，现在看来，立马亭这三个字甚是嘲讽，当时就应驻足返程，坐上缆车，一路轻松愉快。当我四条腿已经支撑不住的时候，终于来到了下一个大站——缆车的终点，玉屏峰。 用一种你们错过了许多景色的神情走过从缆车上下来的人，酸麻的手脚竟然有了昂扬自得的欢呼雀跃感。抬头一望便看到了迎客松。 ​ 腰杆挺直，手舞足蹈，又置身云雾中，像是接引游客去天界的使者。咦？什么时候有的云雾呢？我揉眼再次看去，一切又不一样了：天都峰上刻登峰造极，其险峻如天国之门，其旁的犁云峰上，一只松鼠两腿弯曲，蓄势待发，正要跳入天都；而右侧，山峰如湖中白莲，随风而动，似要飘至眼前。我晃晃脑袋，使意识恢复清醒，眼前玉屏矗立，远处海天相接。黄山最高峰——莲花峰，如海中孤岛。爬山的辛苦，让我下定决心一定不去莲花峰！ ​ 沿山路继续前行，下一个目标是光明顶，飞来石，过百步云梯，一线天，凭借着一股想看到飞来石的意志，我终于登上了莲花峰！没错，我迷路了！没错，我登上了最高峰！一股豪气自心底升起是不存在的，如果可以，我想纵身而下，那么这云海一定是柔软的席梦思床垫，青松为枕，云海做铺，让我好好安眠。 ​ 眼见夕阳西下，再去光明顶，从后山下山的愿望已经破灭，于是重返玉屏峰，爬进缆车里，返程。 ​ 听别的游客说，前山雄，后山秀，原来，我心念已久的黄山美人儿，是双性，而我我只见到它雄的一面。回程的路上，我一直唉声叹气，光明顶，飞来石没见到，更勿论猴子观海梦笔生花。 ​ 后来我想通了，人生难免遗憾嘛，就算做好万全的准备，也不可能观遍所有的风景，给自己留点遗憾，留点念想，留点积极向上努力奋斗下次再来的动力，多好。嗯，近期不想爬山了，如果多年后再来黄山，我只有一个要求，请让我！坐缆车！]]></content>
      <categories>
        <category>travel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[南巡，难寻——宏村]]></title>
    <url>%2Ftravel%2F%E5%8D%97%E5%B7%A1%EF%BC%8C%E9%9A%BE%E5%AF%BB%E2%80%94%E2%80%94%E5%AE%8F%E6%9D%91%2F</url>
    <content type="text"><![CDATA[南巡，难寻——宏村 ​ 一生痴绝处，无梦到徽州。 ​ 辞别南京扬州，从合肥换乘，于4月11日中午抵达黄山市。坐上旅游大巴前往宏村，山间公路状如羊肠，蜿蜒曲折，途中深涧沟壑，陡坡急弯，惊慌中抓住座椅不敢妄动。将头偏向窗外，便是成片的梯田，油菜花花期已过，一片绿汪汪里点缀着零星黄色，更远处层峦叠嶂，云吞雾隐，莫非已至群玉山中？途中经过了齐云山和西递，未作停留，大约一个多小时的山路，便到了宏村。 ​ 青山横北郭，白水绕东城。宏村被群山包围着，像是妙龄女子同时获得了几个强壮男人的青睐。下车便是民宿老板迎至门外，从我手中接过行李，一路指引着到达民宿。入的村内，便见到了传说中的宏村南湖。许是刚下过大雨的缘故，湖水略显浑浊。湖南岸倩影排座，画板斑斓，远看去，画板中画与现实之境相得益彰，恍惚间，自己好似也置身画中，又是谁在用画笔勾勒这山水和我这风度翩翩的伟男子呢？ ​ 无边细雨湿春泥，一边吟过画桥西。山云相接，被青灰色的墨汁自下而上刷过一般，阳光透过淡青色的云雾，给水墨宏村镶上一层金边。卧虎藏龙中李慕白牵马过画桥，一心想交出青冥剑，退隐江湖，过安静平和的日子。然人在江湖，身不由己，为恶者，不能以德服之，还需心中之直，宝剑之利。我身着汉服走在青石板街，此时，我又不是舞文弄墨的酸腐儒生，而是浪迹天涯的仗剑侠客，十步杀一人，千里不留行。 · 宏村大多处在平坦地带，靠山脚，依山势而上，其背倚黄山余脉羊栈领、雷岗山等，地势较高，状似牛型。村口的两颗古树是牛角，村周四处小桥是牛蹄，月沼是牛肚，村庄是牛身。村子屋舍俨然，徽商屋内天花板更是彩绘金丝，不过更喜普通人家的古朴陈旧。来到月沼旁得月楼，得月楼，取自近水楼台先得月之意，餐桌上山笋鲜美，腊肉浓香，猴魁清雅，不禁食欲大开。 ​ 次日清晨，来到村外田野，又是一番清新亮丽之景，在水墨画中，出现了一抹奇色。山脚下的田野上，卧眠的水牛，嚼草的马儿，湿地里，游动的鸭子，山边飘荡的热气球，一片自由祥和。走过水牛骏马热气球，却发现有绳子拴住，连嘎嘎的鸭子，也是用篱笆隔开。是哦，哪有绝对的自由和无拘无束，我身负手铐脚链，眼中全是自由，这便够了。 ​ 玉蝶穿花零碎锦，一天飞絮斗轻狂。走在宏村，走入山野，仿佛我500年前也曾在这，许下来生再会。]]></content>
      <categories>
        <category>travel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[南巡，难寻——扬州]]></title>
    <url>%2Ftravel%2F%E5%8D%97%E5%B7%A1%EF%BC%8C%E9%9A%BE%E5%AF%BB%E2%80%94%E2%80%94%E6%89%AC%E5%B7%9E%2F</url>
    <content type="text"><![CDATA[南巡，难寻——扬州 ​ 一入扬州误终生 ​ 4月8日晚，一下车站，抬头便看到漆黑的夜幕挂着一轮皎月，月儿如钩，勾人心魄。便是无奈三分明月夜，二分无赖是扬州。入住扬州民宿，民宿内桌球沙发，书籍花园，还有英武不凡的黑白花色大猫，被困笼中，上下腾挪，呜咽不息，余感身体乏倦，便卧床休息。​ 4月9日晨，天色灰暗，不见阳光，湿润的空气将泥土花草香气揉捏成团，狠狠的砸在脸上，忽的又散开，无孔不入的乱钻。已是工作日，街上人仍步履缓慢，多见步行或单车，少见四轮驰骋。晃悠至冶春茶社来吃早茶，蟹黄汤包足有拳头般大，吸管插入，鲜亮的汤汁便涌入口中，顿觉香气四溢，食物鲜香与花草芳香在体内混杂交织，又相互争斗，不由得打了个激灵。又吃过五丁包，烧麦，一杯绿杨春入腹，神清气爽赶往瘦西湖。 ​ 行至半程，一股水雾扑面而来，紧接着便是细雨纷飞，我突然慌了，手中无伞，只能快步朝瘦西湖赶，抱怨这不适合旅游的天气。途经商店，买过伞，终于幸免于难。购票进入园中，原来瘦西湖并不只是湖而已，而是湖上园林，瘦西湖原是扬州护城河，是京杭大运河的一条支流。后来扬州盐商在河两岸打造园林风景，逐渐出现了二十四景。如果把杭州西湖比作会向瑶台月下逢的唐朝杨贵妃，那么瘦西湖就是汉代体轻能为掌上舞的赵飞燕，轻盈苗条，小巧玲珑。步行至二十四桥，上桥十二阶，下桥十二阶，传说曾有二十四个江南美女立于桥上弹奏，歌舞，其景诱人。望湖上，红绿掩映间，有“佳人”画船听雨眠，一袭黑衣，曲颈红喙，优雅高贵，不可方物。​ 淮左名都，竹西佳处，烟雨中扬州的瘦西湖，身披轻纱体态轻盈的飞燕，朦胧纤细，仙气四溢，皓腕凝霜，肤若凝脂，流光溢彩，难怪春风十里扬州路，卷上珠帘总不如。祸水红颜也好，身不由己也罢，汉成帝一生有飞燕为伴，夫复何求。 ​ 烟雨后，西湖瘦，雨稍稍停歇，我坐上小船，摇动船桨，行至湖心。四面竹树环合，花香满溢，扬州小调萦绕耳畔，过钓鱼台，五亭桥，白塔，又是一派皇家园林之相。乘船至南门而出，沿河道步行过何园，至东关街口。 ​ 在东关街汉服店中意一身汉服，咬牙买下。行走于古街，甩动魏晋广袖，啜一口桂花酿，提一提深蓝长裙，仿佛置身魏晋时期，我便是那建安七子的曹子建，七步以成诗，见洛神为赋，慨而歌，乐而啸，泼墨为画，曲水流觞，好不自在！ ​ 人言未老莫还乡，我去过的地方，很难再去第二遍，总认为一次就好，一次就尽兴，一次就铭刻于心，深入骨髓，嵌进脑海，留到精神世界去回味。但是扬州，我觉得我还会来第二次，或许会有第三次… ​ 扬州慢我，扬州误我，扬州怡我，人生只合扬州死，禅智山光好墓田！ ​]]></content>
      <categories>
        <category>travel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[南巡，难寻——南京续]]></title>
    <url>%2Ftravel%2F%E5%8D%97%E5%B7%A1%EF%BC%8C%E9%9A%BE%E5%AF%BB%E2%80%94%E2%80%94%E5%8D%97%E4%BA%AC%E7%BB%AD%2F</url>
    <content type="text"><![CDATA[南巡，难寻——南京续 南京理工——二月兰4月8日，昨日游玩的疲惫已被今天的新奇所取代，又是元气满满，精神焕发。伸个懒腰，起床洗漱！ ​ 扯开窗帘，阳光透过玻璃洒落屋内，惊起一片尘纤。洗漱后，收拾行囊放置前台，在火的带领下，来到南理二月兰。 ​ 置身葱绿紫雾之海，我又想起季老的二月兰了，和我眼前的二月兰是否同样呢？是否也无谓悲喜，只是怒放；也是纵浪大化中，一切顺其自然。我俯身向蝴蝶招手，蝴蝶未至，兀自舞动，如雾中仙子，紫气直冲霄汉。于林中穿行，惊起几只白鹭，振动白羽，鸣叫苍穹。 古鸡鸣寺每至一地必看樱。北京玉渊潭，青岛中山公园，武汉等。于是在4月9日下午，樱花大道，一行三人欣然而至。 ​ 转角便是樱花大道，我闭眼屏息，身子向右扭转90度，准备好樱花的绝美之景向我扑来。谁知抬眼望去，枝头无一粉色，便只是绿茫茫一片。风卷过，残花起，4月1日樱花大赏的牌子已显得黄旧，花季过，佳期失，独留残花余香，犹自慰藉游人。 ​ 不免意兴阑珊，却在绿枝掩映间瞧见一抹黄色，细看时，是一座古刹，门口四个苍劲大字——古鸡鸣寺。 ​ 南朝四百八十寺之首，晨钟暮鼓，鸡鸣梵唱。 一路行至香鼎，置身香雾中，按东南西北(我也不知对不对，只知道是顺时针)拜过四方，将香插入鼎中。香气入鼻，不觉已到殿中。抬眼望到大佛宝相庄严，双腿发软，两股战战，膝盖一弯，便跪倒在地。入寺前曾列举想要许下的愿望，此刻却脑海空空，一个也想不起来。放不下的，想得到的，至死不渝的，喜怒哀乐爱欲惧在这一叩尽皆成灰。​ 每个人都有这么一片虚无的精神世界，在那世界中的神明，照见五蕴皆空，渡一切苦厄。僧是佛，道是三清，臣是皇，兵是将，你又是谁？ 玄武湖从古鸡鸣寺出，越古城墙，是玄武湖。 ​ 玄武湖方圆近五里，分作五洲(环洲、樱洲、菱洲、梁洲、翠洲)，洲洲堤桥相通，湖中倒映古城大厦。不知太白重游此地，会否将千余年所作“空余后湖月，波上对江州”拿出撕掉，重绘玄武繁华。 ​ 静坐至溪溪下课，吃过火锅，到车站。农历已是烟花三月，下扬州！]]></content>
      <categories>
        <category>travel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[南巡，难寻——南京]]></title>
    <url>%2Ftravel%2F%E5%8D%97%E5%B7%A1%EF%BC%8C%E9%9A%BE%E5%AF%BB%E2%80%94%E2%80%94%E5%8D%97%E4%BA%AC%2F</url>
    <content type="text"><![CDATA[南巡，难寻——南京 ​ 八天九夜南巡曲终人散，却是一场好聚。江南水乡，草长莺飞，舞榭歌台，眼前尽是南巡春色，心底难寻树俊草香。2019年4月6日周六晚，高铁一路向南疾驰，约2小时后，到达南京南，与虹见面，火火来迎，当晚下榻于南理内酒店。 南京大屠杀纪念馆4月7日晨，吃过学校附近南京汤包与梅干菜锅盔(推荐!)，与火虹来到南京大屠杀纪念馆。 ​ 天空灰蓝，青石斑驳，血与泥土铸成砖，国恨在此，殇也在此。入眼便是一位母亲垂着双臂托着她死去的孩子，她披头散发，双眼无神，身心受到痛楚，灵魂四分五裂。绝望恐惧突然萦绕于心，呼吸急促，步履缓慢。4月，南京却已骄阳，炙问人心。​ 影像难绘地狱之景，血泪难书恶犬之暴，万人坑中层骨堆叠，三十万冤魂长眠此地，历史无言，声若钟磬。​ 烈日为烛，金陵作墓，卷起苍穹祭。华夏之地，群狼环伺，岂曰无衣？与子同袍！ 南京大排档4月7日午，南京大排档。 ​ 印象中，南方是甜口的天下，果不其然，烤鸭是甜的，汤包是甜的，还吃了各种糕，团子，圆子，不过，味蕾在欢呼雀跃的感觉让心情也好了许多～鸡汁汤包面紧实滑软，汁甜中似咸，馅香而不腻，才是只应天上有。 南京总统府吃过午饭，行至南京总统府。 ​ 红花绿树，莺鸣水清，青砖黛瓦，孙文与蒋中正。​ 幼年时，我们总喜欢以好坏来区分我们认识的每个人，生活中或电视里，便是非黑即白。但慢慢发现，世界并不只好坏之分，有墨之白，亦有素之黑。总统府院，景色秀丽，办公之地，严肃整洁。睁眼繁花依旧，闭眼枪炮隆隆，也许孙和蒋也是这样吧，处在这个位置，身前草色青青，眼里却是刀光剑影，你死我活！ 秦淮河 夫子庙 老门东 先锋书店锦衣夜行，幸好有星辉灯火相伴，黄昏见溪溪于地铁，暗赞。​ 四人夜游秦淮，河畔夫子庙老门东各种小食。耳畔萦绕戏腔，黛玉伯虎，烟笼寒水，我昔扬帆掠吴楚，尽阅秦淮八艳的风华。青石板路，微风习习，一路吃来，一路聊来，一路风流。先锋书店，闻着熏香，翻开墨页，静坐至夜深，乐及而归。]]></content>
      <categories>
        <category>travel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SVM]]></title>
    <url>%2FAlgorithm%2FSVM%2F</url>
    <content type="text"><![CDATA[支持向量机(SVM) 间隔在支持向量机中, 我们用间隔刻画划分 超平面与样本之间的距离。 引理1：$\bf{R}^d$空间中某点$p$到超平面$w^Tx+b=0$的距离为 \frac{1}{||w||}|w^Tp+b|​ 定义1：间隔表示距离划分超平面最近的样本到划分超平面距离的两倍, 即 \gamma=2\min_i\frac{1}{||w||}|w^Tp+b|​ 定理1：线性支持向量机的目标是找到一组合适的参数 $(w,b)$, 使得 \max_{w,b}\min_i\frac{2}{||w||}|w^Tp+b| s.t.\ \ \ \ \ \ \ \ \ \ \ y_i(w^Tx_i+b)\gt0,\ \ \ \ \ i=1,2,....m​ ​ 即线性支持向量机希望在特征空间找到一个划分超平面, 将属于不同标记的样本分开, 并且该划分超平面距离 各样本最远 线性支持向量机基本型引理2： 若 $(w^,b^) $是定理3优化问题的解, 那么对任意r &gt; 0, $(rw^,rb^) $仍是该优化问题的解 由于对$(w,b)$的放缩不影响解, 为了简化优化问题, 我们约束$(w,b)$使得 \min_i|w^Tx_i+b|=1因此，定理1等价于 \min_{w,b}\frac{1}{2}w^Tw s.t.\ \ \ \ \ \ \ \ \ \min_iy_i(w^Tx_i+b)=1 对偶问题引理3：对偶问题是主问题的下界，即 \max_{\alpha,\beta}\min_uL(u,\alpha,\beta)\le\min_u\max_{\alpha,\beta}L(u,\alpha,\beta) 线性支持向量机对偶型线性支持向量机的拉格朗日函数为 L(w,b,\alpha)=\frac{1}{2}w^Tw+\sum^m_{i=1}\alpha_i(1-y_i(w^Tx_i+b))描述的优化问题是： \min_{w,b}\max_{\alpha}\frac{1}{2}w^Tw+\sum^m_{i=1}\alpha_i(1-y_i(w^Tx_i+b)) s.t. \ \ \ \ \ \ \ \ \ \alpha_i\ge0,\ \ i=1,2,...,m其对偶问题为 \max_{\alpha}\min_{w,b}\frac{1}{2}w^Tw+\sum^m_{i=1}\alpha_i(1-y_i(w^Tx_i+b))........* s.t. \ \ \ \ \ \ \ \ \ \alpha_i\ge0,\ \ i=1,2,...,m定理2： (线性支持向量机对偶型)线性支持向量机的 对偶问题等价于找到一组合适的参数 $\alpha$, 使得 \min_\alpha\frac{1}{2}\sum^m_{i=1}\sum^m_{j=1}\alpha_i\alpha_jy_iy_jx_i^Tx_j-\sum^m_{i=1}\alpha_i s.t.\ \ \ \ \ \ \ \ \sum^m_{i=1}\alpha_iy_i=0\\ \qquad\qquad\qquad\qquad \alpha_i\ge0,\ \ \ i=1,2,...,m证明： 因为公式$*$内层对$(w,b)$的优化属于无约束优化问题, 我们可以通过令偏导等于零的方法得到$(w,b)$的最优值 \frac{\partial L}{\partial w}=0\Rightarrow w=\sum^m_{i=1}\alpha_iy_ix_i\\ \frac{\partial L}{\partial b}=0\Rightarrow\sum^m_{i=1}\alpha_iy_i=0将其代入公式$*$可得 核函数 非线性可分问题 既然在原始的特征空间$\bf{R}^{d}$不是线性可分的, 支持向量机希望通过一个映射 $\phi: \bf{R}^d →\bf{R}^{\tilde{d}}$, 使得数据在新的空间是线性可分的。a 令$\phi(x)$代表将样本$x$映射到$\bf{R}^{\tilde{d}}$中的特征向量, 参数$w$的维数也要相应变为$\tilde{d}$维。则支持向量机的基本型和对偶型相应变为 \min_{w,b}\frac{1}{2}w^Tw\\ \qquad \qquad s.t.\qquad\qquad y_i(w^T\phi(x_i)+b)\ge1,\qquad i=1,2,...,m \min_\alpha\frac{1}{2}\sum^m_{i=1}\sum^m_{j=1}\alpha_i\alpha_jy_iy_j\phi(x_i)^T\phi(x_i)-\sum^m_{i=1}\alpha_i\\ s.t.\qquad\qquad\sum^m_{i=1}\alpha_iy_i=0,\\ \qquad\qquad\qquad\qquad\qquad\alpha_i\ge0,\qquad i=1,2,...m 核技巧 在支持向量机的对偶型中, 被映射到高维的特征向量总是以成对内积的形式存在, 即$\phi(x_i)^T\phi(x_j)$。如果先计算特征在$\bf{R}^{\tilde{d}}$空间的映射, 再计算内积，会非常的复杂。 核技巧旨在将特征映射和内积这两步运算压缩为一步, 构造一个核函数 $\kappa(x_i,x_j)$, 使得 \kappa(x_i,x_j)=\phi(x_i)^T\phi(x_j)几种常用核函数： | 名称 | 形式 | 优点 | 缺点 || ———— | ——————————————————— | ———————————————————————- | —————————————————- || 线性核 | $x_i^Tx_j$ | 有高效实现，不易过拟合 | 无法解决非线性可分问题 || 多项式核 | $(\beta x_i^Tx_i+\theta)^n$ | 比线性核更一般，$n$直接描述了被映射空间的复杂度 | 参数多，当$n$很大时会导致计算不稳定 || RBF核 | $\exp(-\frac{||x_i-x_j||}{2\alpha^2})$ | 只有一个参数，没有计算不稳定问题 | 计算慢，过拟合风险大 |]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[logistic regression]]></title>
    <url>%2FAlgorithm%2Flogistic-regression%2F</url>
    <content type="text"><![CDATA[逻辑回归 逻辑回归不同于线性回归，虽然带有回归二字，其本质做的是分类的活。 sigmoid函数 sigmoid函数是很常见的一种激活函数，由于其形状像“S”型，又称其为“S”型激活函数。其公式为 g(x) = \frac{1}{1+e^{-x}}函数图像为： 将输出限制在0-1之间，大于等于0.5判为1，小于0.5判为0 代价函数和梯度下降 我们把期望函数定义为： h_\theta(x)=\frac{1}{1+e^{-\theta^Tx}}来表示我们预测的输出，那么，有： P(y=1|x;\theta)=h_{\theta}(x) P(y=0|x;\theta)=1-h_{\theta}(x)可以得到： P(y|x;\theta)=(h_{\theta}(x))^y(1-h_{\theta}(x))^{1-y}最大似然函数为： L(\theta)=Max\prod^m_{i=1}(h_{\theta}(x))^{y_i}(1-h_{\theta}(x))^{1-y_i}化为对数似然： l(\theta)=\log L(\theta)=Max\sum^m_{i=1}(y_i\log(h_{\theta}))+(1-y_i)\log(1-h_{\theta}(x_i))代价函数为： J(\theta)=\frac{1}{m}\sum_{i=1}^{m}[-y^{(i)}\log(h_{\theta}(x^{(i)}))-(1-y^{(i)})\log(1-h_{\theta}(x^{(i)}))]梯度为： \nabla J(\theta)=\frac{1}{m}\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y)x^{(i)}_j仍可使用梯度下降法去更新参数$\theta$ 正则化项正则化是为了消除过拟合而采用的一种方式，将逻辑回归的损失函数加上正则化项，表示为： J(\theta)=\frac{1}{m}\sum_{i=1}^{m}[-y^{(i)}\log(h_{\theta}(x^{(i)}))-(1-y^{(i)})\log(1-h_{\theta}(x^{(i)}))]+\frac{\lambda}{2m}\sum_{j=1}^{n}\theta^2_j梯度为： 对于$j=0$有 \nabla J(\theta)=\frac{1}{m}\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y)x^{(i)}_j对于$j\ge1$有 \nabla J(\theta)=(\frac{1}{m}\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y)x^{(i)}_j)+\frac{\lambda}{m}\theta_j]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[建立github博客]]></title>
    <url>%2Flearning-note%2F%E5%BB%BA%E7%AB%8Bgithub%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[搞github博客从头至尾 建github.io 首先需要申请自己的github账号，在自己的首页点击Repositories,然后点击new，如图所示 然后在name上填写用户名.github.io，接着Create（因为我创建过此仓库，故不可重复） 这个生成好的 Repository 就是用来存放博客内容的地方，也只有这个仓库里的内容，才会被 mycaozf.github.io 这个网页显示出来 Hexo Hexo 是一个博客框架。它把本地文件里的信息生成一个网页。 使用 Hexo 之前，需要先安装 Node.js 和 Git。 操作如下 安装 Node.js 前往 https://nodejs.org/en/ 点击 10.15.0 LTS 下载 安装 打开 cmd， 输入 node -v 得到：v10.15.0 安装成功 安装 Git 前往 https://git-scm.com/ 点击 Downloads 打开 cmd， 输入 git --version 得到：git version 2.20.1.windows 安装成功 安装 Hexo 打开 cmd 输入 npm install -g hexo-cli 回车开始安装 输入 hexo -v 安装成功 创建本地博客 在D盘下创建文件夹 blog 鼠标右键 blog，选择 Git Bash Here。 如果没有安装 Git，就不会有这个选项。 Git Bash 打开之后，所在的位置就是 blog 这个文件夹的位置。（/d/blog） 输入 hexo init 将 blog 文件夹初始化成一个博客文件夹。 输入 npm install 安装依赖包。 输入 hexo g 生成（generate）网页。 由于我们还没创建任何博客，生成的网页会展示 Hexo 里面自带了一个 Hello World 的博客。 输入 hexo s 将生成的网页放在了本地服务器（server）。 浏览器里输入 http://localhost:4000/ 。 就可以看到刚才的成果了。 回到 Git Bash，按 Ctrl+C 结束。 此时再看 http://localhost:4000/ 就是无法访问了。 发布一篇博客 继续在 Git Bash 里，所在路径还是 /d/blog。输入 hexo new &quot;My First Post&quot; 在 D:\blog\source_posts 路径下，会有一个 My-First-Post.md 的文件。 编辑这个文件，然后保存。 回到 Git Bash，输入 hexo g 输入 hexo s 前往 http://localhost:4000/ 查看成果。 回到 Git Bash，按 Ctrl+C 结束 将本地 Hexo 博客部署在 Github 上 操作如下： 获取 Github 对应的 Repository 的链接。 登陆 Github，进入到 mycaozf.github.io 点击 Clone or download 复制 URL 待用 我的是 https://github.com/MyCaoZF/mycaozf.github.io.git 修改博客的配置文件 打开配置文件 /d/blog/_config.yml 找到 1#Deployment 填入以下内容： 1234deploy: type: git repository: https://github.com/MyCaoZF/mycaozf.github.io.git branch: master 部署 回到 Git Bash 输入 npm install hexo-deployer-git --save 安装 hexo-deployer-git 此步骤只需要做一次。 输入 hexo d 得到 INFO Deploy done: git 即为部署成功 之前我们创建的 ReadMe.md 会被自动覆盖掉。 查看成果 前往 mycaozf.github.io 即可。 使用 Next 主题 更多 Hexo 的主题看这里 操作如下： 回到 Git Bash。 输入 git clone https://github.com/iissnan/hexo-theme-next themes/next 这样，该主题的文件就全部克隆到 D:\blog\themes\next 下面。 修改博客配置文件 打开 D:\blog_config.yml 找到 theme: 把 Hexo 默认的 lanscape 修改成 next。 即 theme: next 找到 # Site，添加博客名称，作者名字等。 在 language 后面填入 en 或者 zh-Hans，选择英文或者中文。 找到 # URL, 填入 url。比如 url: https://mycaozf.github.io 填入名字后会有很风骚的 © 2017 CaoZF 的字样出现在博客底部。 重新生成部署即可 回到 Git Bash。输入 hexo g -d就可以了。 先把修改的内容生成网页，再部署。 查看成果 前往 mycaozf.github.io 即可。 在Hexo中使用LaTeX语法输入数学公式 在Hexo中启用MathJax此处以Next主题其为例，在Next中启用MathJax只需要一步。在d/blog/theme/next下找到_config.yml。用文本编辑器找到如下部分： 12345plain _config.yml# MathJax Supportmathjax: enable: false per_page: true cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML 将第二行修改为 1enable: true 即可。 如此以来就在Next主题中启用了MathJax支持，但事实上还存在着不少问题： 部分数学公式直接显示为代码的形式 部分数学公式的下标、角标等显示异常 希腊字母字体显示异常 更换渲染引擎Hexo默认使用hexo-renderer-marked引擎进行网页渲染，其中对许多字符诸如划线、下划线、中括号等定义了转义。因此，在进行网页渲染时，数学公式中的这些字符先通过hexo-renderer-marked进行转义，就发生了歧义，而再通过MathJax渲染出来的数学公式，自然就显示不正常了。在知道了原因以后，问题也就迎刃而解了，解决方法就是更换Hexo默认的hexo-renderer-marked渲染引擎。hexo-renderer-kramed就是一个不错的选择，它在hexo-renderer-marked的基础上修复了一些Bug，其中就包括取消大部分多余的转义。 卸载hexo-renderer-marked，安装hexo-renderer-kramed 1npm install hexo-renderer-kramed --save` 确保所有公式都被渲染在条件支持的情况下，MathJax会对页面上的所有位置的标签内都进行渲染；但在条件不允许时，MathJax对数学公式的渲染可能止于页面上的某个位置，其后的数学公式都将不被渲染而直接显示为代码的形式。这时，就需要在文章的开头font-matter中手动打开MathJax的开关，如下图： 1234title: index.htmldate: 2016-12-28 21:01:30tags:mathjax: true 如上，在使用了数学公式的页面上增加一行 1mathjax: true 这样就能确保页面上所有数学公式都被正确渲染了。 但是以上方法还是不能转换行内公式，即一行内不能够有两对dollar符号，具体解决方法正在试，不过已不影响正常使用！ 参考文献： 在Hexo中使用LaTeX语法输入数学公式 用 Hexo 和 GitHub Pages 搭建博客]]></content>
      <categories>
        <category>learning-note</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[BP]]></title>
    <url>%2FAlgorithm%2FBP%2F</url>
    <content type="text"><![CDATA[反向传播(BP)算法 参数设定$w_{jk}^l$表示第$l-1$层的第$k$个神经元连接到$l$层第$j$个神经元的权重 $b_j^l$表示第$l$层的第$j$个神经元的偏置 $z_j^l$表示第$l$层的第$j$个神经元的输入 z_j^l=\sum_kw_{jk}^la_k^{l-1}+b_j^l$a_j^l$表示第$l$层的第$j$个神经元的输出 a_j^l=\sigma(z_j^l)=\sigma(\sum_kw_{jk}^la_k^{l-1}+b_j^l)其中$\sigma$表示激活函数 $\delta_j^l$表示第$l$层第$j$个神经元中产生的错误 定义为$\delta_j^l=\frac{\partial J}{\partial z_j^l}$ 其中，有$\delta_j^l=\frac{\partial J}{\partial z_j^l}=\frac{\partial J}{\partial a_j^l}\cdot\frac{\partial a_j^l}{\partial z_j^l}$ 用矩阵表示为$\frac{\partial J}{\partial a^L}\odot\frac{\partial a^L}{\partial z^L}=\nabla_aJ\odot\sigma’(z^L)$ ($\odot$表示Hadamard乘积，用于矩阵或向量间点对点乘法运算) 又有 \delta_j^l=\frac{\partial J}{\partial z_j^l}=\sum_k\frac{\partial J}{\partial z_k^{l+1}}\cdot\frac{\partial z_k^{l+1}}{\partial a_j^l}\cdot\frac{\partial a_j^l}{\partial z_k^l}=\sum_k\delta_k^{l+1}\cdot\frac{\partial (w_{kj}^{l+1}a_j^l+b_k^{l+1})}{\partial a_j^l}\cdot\sigma'(z_j^l)=\sum_k\delta_k^{l+1}\cdot w_{kj}^{l+1}\cdot\sigma'(z_j^l)用矩阵表示为$\delta^l = ((w^{l+1})^T\delta^{l+1})\odot\sigma’(z^l)$ 计算梯度计算权重的梯度： \frac{\partial J}{\partial w_{jk}^l}=\frac{\partial J}{\partial z_k^l}\cdot\frac{\partial z_j^l}{\partial w_{jk}^l}=\delta_j^l\cdot\frac{\partial (w_{kj}^la_k^{l-1}+b_j^l)}{\partial w_{jk}^{l}}=a_k^{l-1}\delta_j^l计算偏置的梯度： \frac{\partial J}{\partial b_j^l}=....=\delta_j^l使用梯度下降法使用梯度下降训练参数： w_{jk}^l = w_{jk}^l-\frac{\eta}{m}\delta_j^la_k^{l-1} b_j^l = b_j^l-\frac{\eta}{m}\delta_j^l]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[gradient descent]]></title>
    <url>%2FAlgorithm%2Fgradient-descent%2F</url>
    <content type="text"><![CDATA[梯度下降法 梯度： 在单变量的函数中，梯度就是函数的微分，代表着函数在某个定点切线的斜率。 在多变量函数中，梯度是一个向量，梯度的方向就指出了函数在给定点上升最快的方向 参数更新公式： \theta^1 = \theta^0 - \alpha\nabla J(\theta)​ 其中$\alpha$为步长，$\nabla J(\theta)$为损失函数的梯度，$\theta$为权重 代价函数：​ 衡量模型预测的值$h_{\theta}(x^{(i)})$与真实值$y$之间的差异的函数 形式： 均方误差 J(\theta) = \frac{1}{2m}\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y)^2 $m$为训练样本的个数 \nabla J(\theta)=\frac{1}{m}\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y)x^{(i)} 交叉熵(用于逻辑回归) J(\theta) = -\frac{1}{m}[\sum_{i=1}^{m}(y^{(i)}\log h_{\theta}(x^{(i)})+(1-y^{(i)})\log(1-h_{\theta}(x^{(i)}))] \nabla J(\theta)=\frac{1}{m}\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y)x^{(i)}​ 其中 h_{\theta}(x^{(i)}) = \frac{1}{1+e^{-\theta x}} 用矩阵表示：(均方误差) J(\theta) = \frac{1}{2m}(X\theta-y)^T(X\theta-y) \nabla J(\theta)=\frac{1}{m}X^T(X\theta-y)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[game theory]]></title>
    <url>%2Fread%2Fgame-theory%2F</url>
    <content type="text"><![CDATA[博弈论 一个终极目标博弈的终极目标，是达到纳什均衡，纳什均衡是谋略计算的终点。 七个重要概念【纳什均衡】如果博弈各方都是足够聪明的人，大家最终的策略选择一定是这么一个局面：在这个局面里大家都认命了，谁也无法单方面改变策略去谋求一个对自己更好的结局。 如果一个现象能够在社会中长期稳定地存在，它对参与的各方来说就一定是个纳什均衡。纳什均衡告诉我们评价一个局面不能只看它是不是对整体最好，它必须得让每个参与者都不愿意单方面改变才行。【帕累托最优】帕累托是一位意大利经济学家，帕累托改进的意思是这个改进能在不伤害任何一个人利益的同时，使得至少一个人的境遇变得更好。如果一个局面已经好到没有帕累托改进的余地了，这个局面就叫“帕累托最优”。【压倒性策略】（Dominant Strategy）。在博弈局面中，你有一个策略压倒其他一切策略，不管对手怎么做，这个策略对你来说都是最好的。反之，“被压倒性策略（Dominated Strategy）”，就是不管别人怎么做，你这么做对你都是不好的。【囚徒困境】合作则两利、背叛则两伤。经济学中所谓“负的外部性”、“公地悲剧”、价格战，国际政治中的军备竞赛，动物世界中的互助行为，体育比赛中的使用禁药，医学中的抗生素滥用，包括心理学中的上瘾现象，其实都是囚徒困境。【博弈演化论】专门研究策略的流行规律的学问。博弈的演化，是策略的竞争。如果使用一个策略能带来好的报偿，人们就会模仿这个策略，这个策略就会流行开来。【KMRW定理】用四个经济学家名字的首字母命名。在不完全信息博弈中，参与者不知道对方是好人还是理性人，那么只要博弈重复的次数足够多，合作能带来足够的好处，双方都会愿意维护自己是好人的这样一个声誉，前期尽可能地保持合作，到最后才选择背叛。【Player】在游戏中叫玩家，在体育比赛中叫选手，在博弈论中叫参与者 —— 其实都是一个意思，博弈论（Game Theory）说的都是 game。有一点参与游戏的精神，你就有权在规则范围内采取对自己最有利的行动，你就是积极主动的，你就会平等对待对手 —— 你就既不是一个浑浑噩噩整天根据别人设定做事的人，也不会有整个世界绕着自己转的幻觉。 六个博弈局面博弈局面一：各方有强烈的合作意愿，而博弈有不止一个纳什均衡。采取策略：找到“聚焦点” 一个博弈中会有多个纳什均衡。比如交通规则中“右侧通行”和“左侧通行”，都是纳什均衡。 聚焦点就是在众多可能的纳什均衡中最显眼的那一个，人们会自动在这一点上达成合作。聚焦点的作用是协调。 聚焦点举例：度量衡、键盘、限速牌、指导价、平均年薪……可以是生活习惯，可以是历史传承，可以是传统文化，可以是先下手为强，可以是政府指导，可以是随便找到的什么借口，实在不行还可以抽签。 博弈局面二：囚徒困境——合作对所有人都有好处，但背叛对背叛者有直接的好处。采取策略：如果博弈是可重复的，应该寻求对背叛者进行惩罚。防止背叛，最直观的办法就是把单次博弈变成重复博弈。重复博弈之所以有效，是因为背叛者会受到惩罚。如果博弈是可重复的，应该寻求对背叛者进行惩罚。以牙还牙是最经典的做法，但适当的宽容更能促成合作。 有效的惩罚必须得满足3个条件：你得能发现背叛行为；惩罚必须得是可信的，对方知道他一定会受到惩罚；惩罚的力度得足够。 “以牙还牙”是个保守的策略：1）不管跟谁，第一轮我都选择合作；2）第一轮过后，我就复制对手上一轮的做法。你上一轮要是跟我合作，我下一轮也跟你合作。你要是背叛了我，我下一轮也背叛你。如果你在哪一轮又选择合作了，那我还继续和你合作。我合作，我报复，我原谅，我只是模仿你上一轮的动作。 “以牙还牙”其实是个脆弱的策略：对错误不够友好，它不够宽容。改进版的以牙还牙策略是：对方背叛我一次，我继续合作；只有当对方连续背叛我两次，我再报复。 博弈局面三：参加博弈的人数比较少，合作的利益比较大，各方就会形成串通和合谋，尽管这么做不一定对社会有好处。 戴比尔斯公司的钻石垄断、美国商店的价格匹配、商家之间通过比价网站价格协调、包括大型募捐活动，都是这样的局面。 合作的利益大就不会竞争，背叛的成本低才会背叛。 打破这个局面的一个办法就是扩大市场准入，让更多的参与者进来，让商家的协调没那么容易。另外一个办法就是依靠政府的力量反垄断，相当于全体消费者联合起来去对付那些巨头。 博弈局面四：信息不对称采取策略：传达信息最好的办法是发信号，这意味着你要用行动去证明自己。 一种常见的博弈局面是有一方参与者知道一个关键信息，而另外一方不知道。一方强烈地想让另一方知道他的信息，但是又怕对方不信。一方强烈地想知道对方的信息，但是又怕对方说谎。这就叫“信息不对称”。 花钱、花时间、或者花的是脸面，但又都没什么直接的用处——在博弈论看来，人们做这样的事情，都是为了解决信息不对称。 博弈局面五：最高级的应用：设计博弈 学习博弈论的确有一个比做 player 更高级的视角。那就是做为规则的制定者，去给人设计博弈局面。 房产经纪人薪酬设计、竞拍规则设计，都可以改变局面。但用于真实世界的制度设计，它未必有实用价值。 一般人遵守规则，少数人违反规则，有的人制定规则。设计一个博弈，比参加一个博弈要难得多，这是管理者的学问。 博弈局面六：纳什均衡是博弈的结局，可是真实世界从来都没有结局 —— 这是因为博弈局面总在变化，我们甚至可以主动改变博弈。 六个博弈策略博弈策略一：（装）做好人 在残酷世界里选择做好人表面上看是非理性的 —— 但KMRW定理告诉我们，只要博弈有比较多、哪怕只是有限次的重复，做好人其实是有利的。 但博弈论专家绝对不会建议你去做真正的好人。好人经常对世界有一厢情愿的期待。博弈论专家会说这种想法非常危险。事实上，如果你身处一个比较险恶的社会环境，那你不但不应该做好人，而且应该装坏人。 但好人跟好人之间形成了一个想象的共同体。这其实是一个幻觉，但是没办法，想象的共同体是最强大的社会力量。这其实也是理性的。 博弈策略二：寻求监管 一个破解囚徒困境的直观解决方案：让第三方监管。 监管的本质是改变了博弈的报偿（payoff）。有了有效的监管，不合作就不但没有好处，而且还会受到惩罚，不合作的行为自然就会大大减少。 比自己管、私有化和政府管这三种监管方法更新颖的是让博弈各方之外的“第四方”监管。更高级的监管是监管者和被监管者的合作。 你应该把政府也当做一个 player。而且政府也应该把自己视为一个 player。既然是参加博弈的 player，政府也需要博弈论。 博弈策略三：先下手为强＋后发者优势 动态博弈 小鸡博弈：只要你能确定对手的底线，那么先发制人，造成既成事实，就能逼迫对手就范。 悬崖策略是动态进行的小鸡游戏。双方每一步都在推动危机升级，这是一个危险的边缘游戏。 最好的办法给对方一个威慑，让他根本不敢出手。威慑有三个要素：实力、决心和让对手知道。 先发者暴露信息，后发者利用信息。 后发优势 = 先发者的信息 + 后发者的出手权。信息是模仿机会，出手权是创新机会。 博弈策略四：威胁和承诺 威胁和承诺都是在博弈双方都没有采取实质性行动之前，一方通知另一方的声明。所谓威胁，就是我要求你不要去做某件事 —— 我说如果你做了，我就会对你进行惩罚。所谓承诺，就是我要求你去做某件事 —— 如果你做了，我就会给你一个奖励。 只有可信的威胁和承诺才有意义。 可信 = 别无选择。发出可信的威胁或者承诺有三个办法：给别人惩罚你的权力；主动取消自己的选项；建立声望。 博弈策略五：随机选择策略 只说谎话就等于只说实话。想要真的迷惑对手，你必须把谎话和实话混合起来。 你的混合概率选择，应该把对手能得到的最大报偿给最小化。你要按照一定的概率，混合自己的打法。你混合打法的这个规律，必须是让对手无法利用的。 不是真随机，就会被破解。随机性，才是真正的“诡道”。 博弈策略六：最高视角：观察不同博弈策略在人群中的演化。博弈永无休止。 即便纳什均衡并不只有一种，冥冥之中仍然存在着一些规律，在限制我们选择策略的自由。这些规律决定了社会的演化。 如果使用一个策略能带来好的报偿，人们就会模仿这个策略，这个策略就会流行开来。 策略的优劣不是永恒的。你必须考虑当前社会的博弈格局，特别是其他人都在使用什么策略，才知道自己的最佳策略是什么。到底要在什么比例的情况下随大流，甚至要不要随大流，都取决于具体的博弈格局。 若干金句＊计谋要是太多，愚蠢的人就不够用了。博弈论研究的是理性人之间的博弈。＊研究博弈论就好像下棋一样，你要考虑你的每一个行动都是有后果的，你要事先想好对方会有什么反应，然后你再怎么应对，然后对方再反应……一直到最后是个什么结果。＊理想青年喜欢帕累托最优，理性青年寻找纳什均衡。＊博弈论是人类理性行为的第一性原理。＊有一种困境叫自由，有一种解放叫禁止。＊我们年轻时候的雄心壮志变成了对社会的低头，我们感慨世风日下人心不古，我们嘱咐子女不要锋芒毕露，可我们又暗自期望他们能走一条少有人走的路。一切都仿佛是个性和现实之间的对抗，殊不知一切的背后……都是数学。＊所有人都意识不到博弈的时候，可能你诗情画意都能赢。少数人意识到博弈的时候，谁意识到博弈谁赢。大家都意识到博弈了，那就只能比执行力 —— 或者看谁能意识到新的博弈。＊一个合格的 player，应该拥有四个作风 —— 有限、务实、慎重、客观。]]></content>
      <categories>
        <category>read</category>
      </categories>
  </entry>
</search>
