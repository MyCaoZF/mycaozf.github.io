<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>建立github博客</title>
      <link href="/uncategorized/%E5%BB%BA%E7%AB%8Bgithub%E5%8D%9A%E5%AE%A2/"/>
      <url>/uncategorized/%E5%BB%BA%E7%AB%8Bgithub%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="搞github博客从头至尾"><a href="#搞github博客从头至尾" class="headerlink" title="搞github博客从头至尾"></a>搞github博客从头至尾</h3><a id="more"></a><ul><li><h4 id="建github-io"><a href="#建github-io" class="headerlink" title="建github.io"></a>建github.io</h4></li></ul><hr><p>首先需要申请自己的github账号，在自己的首页点击<strong>Repositories</strong>,然后点击<strong>new</strong>，如图所示</p><p><img src="/2019/01/08/建立github博客/1546954199271.jpg" alt=""></p><p>然后在name上填写用户名.github.io，接着Create（因为我创建过此仓库，故不可重复）</p><p><img src="/2019/01/08/建立github博客/1546954336467.jpg" alt=""></p><p>这个生成好的 Repository 就是用来存放博客内容的地方，也只有这个仓库里的内容，才会被 mycaozf.github.io 这个网页显示出来</p><ul><li><h4 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h4></li></ul><hr><p>Hexo 是一个博客框架。它把本地文件里的信息生成一个网页。</p><p>使用 Hexo 之前，需要先安装 Node.js 和 Git。</p><h5 id="操作如下"><a href="#操作如下" class="headerlink" title="操作如下"></a>操作如下</h5><ol><li><p>安装 Node.js</p><ul><li><p>前往 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p></li><li><p>点击 10.15.0 LTS 下载</p></li><li><p>安装</p></li><li><p>打开 cmd， 输入 <code>node -v</code></p></li><li><p>得到：v10.15.0</p><p>安装成功</p></li></ul></li><li><p>安装 Git</p><ul><li><p>前往 <a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p></li><li><p>点击 Downloads</p></li><li><p>打开 cmd， 输入 <code>git --version</code></p></li><li><p>得到：git version 2.20.1.windows</p><p>安装成功</p></li></ul></li><li><p>安装 Hexo</p><ul><li><p>打开 cmd</p></li><li><p>输入 <code>npm install -g hexo-cli</code></p></li><li><p>回车开始安装</p></li><li><p>输入 <code>hexo -v</code></p><p>安装成功</p></li></ul></li><li><p>创建本地博客</p><ul><li><p>在D盘下创建文件夹 blog</p></li><li><p>鼠标右键 blog，选择 Git Bash Here。 如果没有安装 Git，就不会有这个选项。</p></li><li><p>Git Bash 打开之后，所在的位置就是 blog 这个文件夹的位置。（/d/blog）</p></li><li><p>输入 <code>hexo init</code> 将 blog 文件夹初始化成一个博客文件夹。</p></li><li><p>输入 <code>npm install</code> 安装依赖包。</p></li><li><p>输入 <code>hexo g</code> 生成（generate）网页。 由于我们还没创建任何博客，生成的网页会展示 Hexo 里面自带了一个 Hello World 的博客。</p></li><li><p>输入 <code>hexo s</code> 将生成的网页放在了本地服务器（server）。</p></li><li><p>浏览器里输入 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 。 就可以看到刚才的成果了。</p></li><li><p>回到 Git Bash，按 Ctrl+C 结束。</p><p>此时再看 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 就是无法访问了。</p></li></ul></li><li><p>发布一篇博客</p><ul><li>继续在 Git Bash 里，所在路径还是 /d/blog。输入 <code>hexo new &quot;My First Post&quot;</code></li><li>在 D:\blog\source_posts 路径下，会有一个 My-First-Post.md 的文件。 编辑这个文件，然后保存。</li><li>回到 Git Bash，输入 <code>hexo g</code></li><li>输入 <code>hexo s</code></li><li>前往 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 查看成果。</li><li>回到 Git Bash，按 Ctrl+C 结束</li></ul></li></ol><ul><li><h4 id="将本地-Hexo-博客部署在-Github-上"><a href="#将本地-Hexo-博客部署在-Github-上" class="headerlink" title="将本地 Hexo 博客部署在 Github 上"></a>将本地 Hexo 博客部署在 Github 上</h4><hr><h5 id="操作如下："><a href="#操作如下：" class="headerlink" title="操作如下："></a>操作如下：</h5><ol><li><p>获取 Github 对应的 Repository 的链接。</p><ul><li><p>登陆 Github，进入到 mycaozf.github.io</p></li><li><p>点击 Clone or download</p></li><li><p>复制 URL 待用</p><p>我的是 <code>https://github.com/MyCaoZF/mycaozf.github.io.git</code></p></li></ul></li><li><p>修改博客的配置文件</p><ul><li><p>打开配置文件 /d/blog/_config.yml </p></li><li><p>找到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#Deployment</span><br></pre></td></tr></table></figure><p>填入以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:  </span><br><span class="line">  type: git  </span><br><span class="line">  repository: https://github.com/MyCaoZF/mycaozf.github.io.git  </span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li></ul></li><li><p>部署</p><ul><li><p>回到 Git Bash</p></li><li><p>输入 <code>npm install hexo-deployer-git --save</code> 安装 hexo-deployer-git 此步骤只需要做一次。</p></li><li><p>输入 <code>hexo d</code></p></li><li><p>得到 <code>INFO Deploy done: git</code> 即为部署成功</p><p>之前我们创建的 ReadMe.md 会被自动覆盖掉。</p></li></ul></li><li><p>查看成果</p><p>前往 mycaozf.github.io 即可。</p></li></ol></li><li><h4 id="使用-Next-主题"><a href="#使用-Next-主题" class="headerlink" title="使用 Next 主题"></a>使用 Next 主题</h4></li></ul><hr><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">更多 Hexo 的主题看这里</a></p><h5 id="操作如下：-1"><a href="#操作如下：-1" class="headerlink" title="操作如下："></a>操作如下：</h5><ol><li><p>回到 Git Bash。 输入 <code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code></p><p>这样，该主题的文件就全部克隆到 D:\blog\themes\next 下面。</p></li><li><p>修改博客配置文件</p><ul><li><p>打开 D:\blog_config.yml</p></li><li><p>找到 <code>theme:</code></p></li><li><p>把 Hexo 默认的 lanscape 修改成 next。 即 <code>theme: next</code></p></li><li><p>找到 <code># Site</code>，添加博客名称，作者名字等。</p></li><li><p>在 <code>language</code> 后面填入 en 或者 zh-Hans，选择英文或者中文。</p></li><li><p>找到 <code># URL</code>, 填入 url。比如 <code>url: https://mycaozf.github.io</code></p><p>填入名字后会有很风骚的 © 2017 CaoZF 的字样出现在博客底部。</p></li></ul></li><li><p>重新生成部署即可</p><ul><li><p>回到 Git Bash。输入 <code>hexo g -d</code>就可以了。</p><p>先把修改的内容生成网页，再部署。</p></li></ul></li><li><p>查看成果</p><p>前往 mycaozf.github.io 即可。</p></li></ol><ul><li><h4 id="在Hexo中使用LaTeX语法输入数学公式"><a href="#在Hexo中使用LaTeX语法输入数学公式" class="headerlink" title="在Hexo中使用LaTeX语法输入数学公式"></a>在Hexo中使用LaTeX语法输入数学公式</h4></li></ul><hr><h5 id="在Hexo中启用MathJax"><a href="#在Hexo中启用MathJax" class="headerlink" title="在Hexo中启用MathJax"></a>在Hexo中启用MathJax</h5><p>此处以Next主题其为例，在Next中启用MathJax只需要一步。在<code>d/blog/theme/next</code>下找到<code>_config.yml</code>。用文本编辑器找到如下部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plain _config.yml# MathJax Support</span><br><span class="line">mathjax:</span><br><span class="line">  enable: false</span><br><span class="line">  per_page: true</span><br><span class="line">  cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML</span><br></pre></td></tr></table></figure><p>将第二行修改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enable: true</span><br></pre></td></tr></table></figure><p>即可。</p><p>如此以来就在Next主题中启用了MathJax支持，但事实上还存在着不少问题：</p><ul><li>部分数学公式直接显示为代码的形式</li><li>部分数学公式的下标、角标等显示异常</li><li>希腊字母字体显示异常</li></ul><h5 id="更换渲染引擎"><a href="#更换渲染引擎" class="headerlink" title="更换渲染引擎"></a>更换渲染引擎</h5><p>Hexo默认使用<code>hexo-renderer-marked</code>引擎进行网页渲染，其中对许多字符诸如划线、下划线、中括号等定义了转义。因此，在进行网页渲染时，数学公式中的这些字符先通过<code>hexo-renderer-marked</code>进行转义，就发生了歧义，而再通过MathJax渲染出来的数学公式，自然就显示不正常了。<br>在知道了原因以后，问题也就迎刃而解了，解决方法就是更换Hexo默认的<code>hexo-renderer-marked</code>渲染引擎。<code>hexo-renderer-kramed</code>就是一个不错的选择，它在<code>hexo-renderer-marked</code>的基础上修复了一些Bug，其中就包括取消大部分多余的转义。</p><p>卸载<code>hexo-renderer-marked</code>，安装<code>hexo-renderer-kramed</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-kramed --save`</span><br></pre></td></tr></table></figure><h5 id="确保所有公式都被渲染"><a href="#确保所有公式都被渲染" class="headerlink" title="确保所有公式都被渲染"></a>确保所有公式都被渲染</h5><p>在条件支持的情况下，MathJax会对页面上的所有位置的标签内都进行渲染；但在条件不允许时，MathJax对数学公式的渲染可能止于页面上的某个位置，其后的数学公式都将不被渲染而直接显示为代码的形式。<br>这时，就需要在文章的开头font-matter中手动打开MathJax的开关，如下图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: index.html</span><br><span class="line">date: 2016-12-28 21:01:30</span><br><span class="line">tags:</span><br><span class="line">mathjax: true</span><br></pre></td></tr></table></figure><p>如上，在使用了数学公式的页面上增加一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mathjax: true</span><br></pre></td></tr></table></figure><p>这样就能确保页面上所有数学公式都被正确渲染了。</p><p>但是以上方法还是不能转换行内公式，即一行内不能够有两对dollar符号，具体解决方法正在试，不过已不影响正常使用！</p><p><strong>参考文献</strong>：</p><p><a href="https://www.once4623.site/2017/10/03/2017-10-04--Use-MathJax-In-Hexo-Next/" target="_blank" rel="noopener">在Hexo中使用LaTeX语法输入数学公式</a></p><p><a href="https://ryanluoxu.github.io/2017/11/24/%E7%94%A8-Hexo-%E5%92%8C-GitHub-Pages-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">用 Hexo 和 GitHub Pages 搭建博客</a></p><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BP</title>
      <link href="/uncategorized/BP/"/>
      <url>/uncategorized/BP/</url>
      
        <content type="html"><![CDATA[<h3 id="反向传播-BP-算法"><a href="#反向传播-BP-算法" class="headerlink" title="反向传播(BP)算法"></a>反向传播(BP)算法</h3><a id="more"></a><h4 id="参数设定"><a href="#参数设定" class="headerlink" title="参数设定"></a>参数设定</h4><p>$w_{jk}^l$表示第$l-1$层的第$k$个神经元连接到$l$层第$j$个神经元的权重</p><p>$b_j^l$表示第$l$层的第$j$个神经元的偏置</p><p>$z_j^l$表示第$l$层的第$j$个神经元的输入</p><script type="math/tex; mode=display">z_j^l=\sum_kw_{jk}^la_k^{l-1}+b_j^l</script><p>$a_j^l$表示第$l$层的第$j$个神经元的输出</p><script type="math/tex; mode=display">a_j^l=\sigma(z_j^l)=\sigma(\sum_kw_{jk}^la_k^{l-1}+b_j^l)</script><p>其中$\sigma$表示激活函数</p><p>$\delta_j^l$表示第$l$层第$j$个神经元中产生的错误</p><p>定义为$\delta_j^l=\frac{\partial J}{\partial z_j^l}$    </p><p>其中，有$\delta_j^l=\frac{\partial J}{\partial z_j^l}=\frac{\partial J}{\partial a_j^l}\cdot\frac{\partial a_j^l}{\partial z_j^l}$                                      </p><p>用矩阵表示为$\frac{\partial J}{\partial a^L}\odot\frac{\partial a^L}{\partial z^L}=\nabla_aJ\odot\sigma’(z^L)$     ($\odot$表示Hadamard乘积，用于矩阵或向量间点对点乘法运算)</p><p>又有</p><script type="math/tex; mode=display">\delta_j^l=\frac{\partial J}{\partial z_j^l}=\sum_k\frac{\partial J}{\partial z_k^{l+1}}\cdot\frac{\partial  z_k^{l+1}}{\partial a_j^l}\cdot\frac{\partial a_j^l}{\partial z_k^l}=\sum_k\delta_k^{l+1}\cdot\frac{\partial (w_{kj}^{l+1}a_j^l+b_k^{l+1})}{\partial a_j^l}\cdot\sigma'(z_j^l)=\sum_k\delta_k^{l+1}\cdot w_{kj}^{l+1}\cdot\sigma'(z_j^l)</script><p>用矩阵表示为$\delta^l = ((w^{l+1})^T\delta^{l+1})\odot\sigma’(z^l)$</p><h4 id="计算梯度"><a href="#计算梯度" class="headerlink" title="计算梯度"></a>计算梯度</h4><p>计算权重的梯度：</p><script type="math/tex; mode=display">\frac{\partial J}{\partial w_{jk}^l}=\frac{\partial J}{\partial z_k^l}\cdot\frac{\partial z_j^l}{\partial w_{jk}^l}=\delta_j^l\cdot\frac{\partial (w_{kj}^la_k^{l-1}+b_j^l)}{\partial w_{jk}^{l}}=a_k^{l-1}\delta_j^l</script><p>计算偏置的梯度：</p><script type="math/tex; mode=display">\frac{\partial J}{\partial b_j^l}=....=\delta_j^l</script><h4 id="使用梯度下降法"><a href="#使用梯度下降法" class="headerlink" title="使用梯度下降法"></a>使用梯度下降法</h4><p>使用梯度下降训练参数：</p><script type="math/tex; mode=display">w_{jk}^l = w_{jk}^l-\frac{\eta}{m}\delta_j^la_k^{l-1}</script><script type="math/tex; mode=display">b_j^l = b_j^l-\frac{\eta}{m}\delta_j^l</script>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gradient descent</title>
      <link href="/uncategorized/gradient-descent/"/>
      <url>/uncategorized/gradient-descent/</url>
      
        <content type="html"><![CDATA[<h3 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h3><a id="more"></a><h5 id="梯度："><a href="#梯度：" class="headerlink" title="梯度："></a>梯度：</h5><ul><li>在单变量的函数中，梯度就是函数的微分，代表着函数在某个定点切线的斜率。</li><li>在多变量函数中，梯度是一个向量，梯度的方向就指出了函数在给定点上升最快的方向</li></ul><h5 id="参数更新公式："><a href="#参数更新公式：" class="headerlink" title="参数更新公式："></a>参数更新公式：</h5><script type="math/tex; mode=display">\theta^1 = \theta^0 - \alpha\nabla J(\theta)</script><p>​    其中$\alpha$为步长，$\nabla J(\theta)$为损失函数的梯度，$\theta$为权重</p><h5 id="代价函数："><a href="#代价函数：" class="headerlink" title="代价函数："></a>代价函数：</h5><p>​    衡量模型预测的值$h_{\theta}(x^{(i)})$与真实值$y$之间的差异的函数</p><p>形式：</p><ul><li>均方误差<script type="math/tex; mode=display">J(\theta) = \frac{1}{2m}\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y)^2</script>  $m$为训练样本的个数<script type="math/tex; mode=display">\nabla J(\theta)=\frac{1}{m}\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y)x^{(i)}</script></li></ul><ul><li><p>交叉熵(用于逻辑回归)</p><script type="math/tex; mode=display">J(\theta) = -\frac{1}{m}[\sum_{i=1}^{m}(y^{(i)}\log h_{\theta}(x^{(i)})+(1-y^{(i)})\log(1-h_{\theta}(x^{(i)}))]</script><script type="math/tex; mode=display">\nabla J(\theta)=\frac{1}{m}\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y)x^{(i)}</script><p>​    其中</p><script type="math/tex; mode=display">h_{\theta}(x^{(i)}) = \frac{1}{1+e^{-\theta x}}</script></li></ul><h5 id="用矩阵表示：-均方误差"><a href="#用矩阵表示：-均方误差" class="headerlink" title="用矩阵表示：(均方误差)"></a>用矩阵表示：(均方误差)</h5><script type="math/tex; mode=display">        J(\theta) = \frac{1}{2m}(X\theta-y)^T(X\theta-y)</script><script type="math/tex; mode=display">\nabla J(\theta)=\frac{1}{m}X^T(X\theta-y)</script>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
